"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require("crypto");
var xml2js_1 = require("xml2js");
var md5 = function (contents) {
    return crypto
        .createHash('md5')
        .update(contents)
        .digest('hex');
};
function createChallengeString() {
    return '<methodCall><methodName>challenge</methodName><params></params></methodCall>';
}
exports.createChallengeString = createChallengeString;
function createChallengeResponseString(upTime, password) {
    // by doing md5(uptime:password)
    return "<methodCall><methodName>authenticate</methodName><params><param><value><string>" + md5(upTime + ":" + password) + "</string></value></param></params></methodCall>";
}
exports.createChallengeResponseString = createChallengeResponseString;
function createCommandString(command) {
    return "<methodCall><methodName>" + command + "</methodName><params></params></methodCall>";
}
exports.createCommandString = createCommandString;
function getUpTimeFromChallengeResponse(str) {
    // server response looks like
    // <methodResponse><params><param><value><string>31268616.000000</string></value></param></params></methodResponse>
    // get the uptime by parsing the xml
    var upTime = '';
    xml2js_1.parseString(str, function (err, result) {
        if (!err) {
            upTime = result.methodResponse.params[0].param[0].value[0].string[0];
        }
    });
    return upTime;
}
exports.getUpTimeFromChallengeResponse = getUpTimeFromChallengeResponse;
function parseCommandResponse(str) {
    // server response looks like
    // <methodResponse><params><param><value><string>{server response}</string></value></param></params></methodResponse>
    var res = '';
    xml2js_1.parseString(str, function (err, result) {
        // parse the response
        if (!err) {
            res = result.methodResponse.params[0].param[0].value[0].string[0];
        }
    });
    return res;
}
exports.parseCommandResponse = parseCommandResponse;
function parseAuthResponse(data) {
    // server response looks like this
    // <?xml version='1.0'?>
    // <methodResponse>
    // <params><param><value><string>authorized</string></value></param></params>
    // </methodResponse>
    // sometimes auth passes after a few tries it just keeps the connection open
    // Handle auth failed here
    // TODO: Probably could look into this a little further
    var authResults = '';
    xml2js_1.parseString(data, function (err, result) {
        if (!err) {
            authResults = result.methodResponse.params[0].param[0].value[0].string[0];
        }
    });
    return authResults;
}
exports.parseAuthResponse = parseAuthResponse;
function isIllegalCommand(res) {
    // server response looks like
    // <methodResponse><params><param><value>
    // <string> [Whitelist] Invalid command: challenge</string></value></param></params>
    // </methodResponse>
    // find out if it says Illegal Command
    var responseString = '';
    var commandRegex = new RegExp(/\[Whitelist] Invalid command: .*/g);
    xml2js_1.parseString(res.data, function (err, result) {
        if (!err) {
            responseString = result.methodResponse.params[0].param[0].value[0].string[0];
        }
    });
    return commandRegex.exec(responseString) !== null;
}
exports.isIllegalCommand = isIllegalCommand;
var preserveCamelCase = function (input) {
    var isLastCharLower = false;
    var isLastCharUpper = false;
    var isLastLastCharUpper = false;
    for (var i = 0; i < input.length; i++) {
        var c = input[i];
        if (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {
            input = input.slice(0, i) + '-' + input.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
        }
        else if (isLastCharUpper &&
            isLastLastCharUpper &&
            /[a-zA-Z]/.test(c) &&
            c.toLowerCase() === c) {
            input = input.slice(0, i - 1) + '-' + input.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
        }
        else {
            isLastCharLower = c.toLowerCase() === c;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = c.toUpperCase() === c;
        }
    }
    return input;
};
exports.camelCase = function (input, options) {
    options = __assign(__assign({}, options), { pascalCase: false });
    var postProcess = function (x) { return (options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x); };
    if (Array.isArray(input)) {
        input = input
            .map(function (x) { return x.trim(); })
            .filter(function (x) { return x.length; })
            .join('-');
    }
    else {
        input = input.trim();
    }
    if (input.length === 0) {
        return '';
    }
    if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
    }
    if (/^[a-z\d]+$/.test(input)) {
        return postProcess(input);
    }
    var hasUpperCase = input !== input.toLowerCase();
    if (hasUpperCase) {
        input = preserveCamelCase(input);
    }
    input = input
        .replace(/^[_.\- ]+/, '')
        .toLowerCase()
        .replace(/[_.\- ]+(\w|$)/g, function (m, p1) { return p1.toUpperCase(); });
    return postProcess(input);
};
//# sourceMappingURL=utils.js.map